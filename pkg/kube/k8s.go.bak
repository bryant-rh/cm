package kube

import (
	"bytes"
	"context"
	"fmt"
	"io"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	syaml "k8s.io/apimachinery/pkg/runtime/serializer/yaml"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/util/yaml"

	"k8s.io/client-go/dynamic"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/restmapper"

	sigyaml "sigs.k8s.io/yaml"
)

type KubeClient struct {
	ApiClient      *kubernetes.Clientset
	Dynameicclient dynamic.Interface
}

// NewClient creates a new client to get data from kubernetes masters
func NewClient(config *rest.Config) (*KubeClient, error) {
	// We got two clients, one for the common API and one explicitly for metrics
	client, err := kubernetes.NewForConfig(config)
	if err != nil {
		return nil, fmt.Errorf("error creating kubernetes main client: '%v'", err)
	}

	dynameicclient, err := dynamic.NewForConfig(config)
	if err != nil {
		return nil, fmt.Errorf("error creating kubernetes dynamic client: '%v'", err)
	}

	return &KubeClient{
		ApiClient:      client,
		Dynameicclient: dynameicclient,
	}, nil
}

type ApplyYaml struct {
	client    KubeClient
	ApplyYaml string
	Namespace string
	ApplyErr  map[string]error
}

func NewApplyYaml(data string, ns string, client *KubeClient) *ApplyYaml {

	return &ApplyYaml{
		client:    *client,
		ApplyYaml: data,
		Namespace: ns,
		ApplyErr:  map[string]error{},
	}
}

func (y *ApplyYaml) CreateOrUpdateFromYaml() {

	//序列化为yaml
	d := yaml.NewYAMLOrJSONDecoder(bytes.NewBufferString(y.ApplyYaml), 4096)

	for {

		var (
			rawObj runtime.RawExtension
		)

		err := d.Decode(&rawObj)
		if err == io.EOF {

			break
		}
		if err != nil {

			y.ApplyErr["decode"] = fmt.Errorf("decode is err %v", err)
			continue
		}

		obj, _, err := syaml.NewDecodingSerializer(unstructured.UnstructuredJSONScheme).Decode(rawObj.Raw, nil, nil)
		if err != nil {

			y.ApplyErr["decode"] = fmt.Errorf("rawobj is err%v", err)
			continue
		}

		unstructuredMap, err := runtime.DefaultUnstructuredConverter.ToUnstructured(obj)
		if err != nil {

			y.ApplyErr["decode"] = fmt.Errorf("tounstructured is err %v", err)
			continue
		}

		unstructureObj := &unstructured.Unstructured{
			Object: unstructuredMap}
		gvr, err := y.GtGVR(unstructureObj.GroupVersionKind(), y.client)
		if err != nil {

			y.ApplyErr[unstructureObj.GetName()] = fmt.Errorf("get gvr is false %v", err)
			continue
		}

		unstructuredYaml, err := sigyaml.Marshal(unstructureObj)
		if err != nil {

			y.ApplyErr[unstructureObj.GetName()] = fmt.Errorf("unable to marshal resource as yaml: %w", err)
			continue
		}

		if y.Namespace != "" && unstructureObj.GetNamespace() != "" && y.Namespace != unstructureObj.GetNamespace() {

			y.ApplyErr[unstructureObj.GetName()] = fmt.Errorf("the namespace from the provided object %v does not match the namespace %v", y.Namespace, unstructureObj.GetNamespace())
			continue
		}

		if y.Namespace == "" && unstructureObj.GetNamespace() == "" {

			unstructureObj.SetNamespace("default")
		}

		_, err = y.client.Dynameicclient.Resource(gvr).Namespace(y.Namespace).Get(context.Background(), unstructureObj.GetName(), metav1.GetOptions{})
		if err != nil {

			_, createErr := y.client.Dynameicclient.Resource(gvr).Namespace(y.Namespace).Create(context.Background(), unstructureObj, metav1.CreateOptions{})
			if createErr != nil {

				y.ApplyErr[unstructureObj.GetName()] = fmt.Errorf("create err is :%v", createErr)
				continue
			}
			fmt.Printf("create %v %v \n", unstructureObj.GetKind(), unstructureObj.GetName())
			continue
		}

		force := true

		_, err = y.client.Dynameicclient.Resource(gvr).
			Namespace(unstructureObj.GetNamespace()).
			Patch(context.Background(),
				unstructureObj.GetName(),
				types.ApplyPatchType,
				unstructuredYaml, metav1.PatchOptions{

					FieldManager: unstructureObj.GetName(),
					Force:        &force,
				})

		if err != nil {

			y.ApplyErr[unstructureObj.GetName()] = fmt.Errorf("unable to patch resource: %w", err)
			continue
		}
	}

}

func (y *ApplyYaml) GtGVR(gvk schema.GroupVersionKind, client KubeClient) (schema.GroupVersionResource, error) {

	gr, err := restmapper.GetAPIGroupResources(client.ApiClient)
	if err != nil {

		return schema.GroupVersionResource{}, err
	}

	mapper := restmapper.NewDiscoveryRESTMapper(gr)

	mapping, err := mapper.RESTMapping(gvk.GroupKind(), gvk.Version)
	if err != nil {

		return schema.GroupVersionResource{}, err
	}

	return mapping.Resource, nil
}
